<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>修真RPG · 时光与寿元</title>
  <style>

    :root{
      --bg:#0b0f14;
      --panel:#111827;
      --panel2:#0f172a;
      --card:#0b1220;
      --text:#e5e7eb;
      --muted:#9ca3af;
      --line:#243042;
      --accent:#60a5fa;
      --good:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;
      --btn:#1f2937;
      --btn2:#111827;
      --shadow: 0 10px 25px rgba(0,0,0,.35);
      --radius:16px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background: radial-gradient(1200px 800px at 20% -20%, rgba(96,165,250,.25), transparent 60%),
                  radial-gradient(900px 600px at 110% 10%, rgba(52,211,153,.18), transparent 55%),
                  radial-gradient(900px 600px at 30% 120%, rgba(251,113,133,.10), transparent 55%),
                  var(--bg);
      color:var(--text);
      font-family:var(--sans);
      letter-spacing:.2px;
    }
    a{color:var(--accent); text-decoration:none}
    .app{
      max-width:1300px;
      margin:0 auto;
      padding:18px;
      display:grid;
      grid-template-columns: 320px 1fr 360px;
      gap:16px;
    }
    .topbar{
      max-width:1300px;
      margin:0 auto;
      padding:18px 18px 0 18px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .brand{
      display:flex; align-items:center; gap:10px;
    }
    .logo{
      width:38px;height:38px;border-radius:12px;
      background: linear-gradient(135deg, rgba(96,165,250,.9), rgba(52,211,153,.9));
      box-shadow: var(--shadow);
    }
    .brand h1{font-size:16px; margin:0}
    .brand .sub{font-size:12px; color:var(--muted); margin-top:2px}
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px;
      border:1px solid var(--line);
      background: rgba(17,24,39,.65);
      border-radius:999px;
      font-size:12px;
      color:var(--muted);
    }
    .pill b{color:var(--text); font-weight:600}
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .panel{
      background: rgba(17,24,39,.75);
      border:1px solid rgba(36,48,66,.85);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .panel .hd{
      padding:14px 14px 10px 14px;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
      border-bottom:1px solid rgba(36,48,66,.75);
      background: linear-gradient(180deg, rgba(15,23,42,.7), rgba(17,24,39,.55));
    }
    .panel .hd h2{margin:0; font-size:13px; letter-spacing:.3px}
    .panel .hd .hint{font-size:12px; color:var(--muted); margin-top:4px; line-height:1.45}
    .panel .bd{padding:14px}
    .card{
      background: rgba(11,18,32,.55);
      border:1px solid rgba(36,48,66,.7);
      border-radius:14px;
      padding:12px;
    }
    .statgrid{
      display:grid;
      grid-template-columns: repeat(2,1fr);
      gap:10px;
    }
    .kv{
      display:flex; align-items:center; justify-content:space-between;
      gap:12px;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid rgba(36,48,66,.55);
      background: rgba(11,18,32,.45);
      font-size:12px;
    }
    .kv span{color:var(--muted)}
    .kv b{font-weight:650}
    .progress{
      height:10px;
      border-radius:999px;
      background: rgba(36,48,66,.7);
      overflow:hidden;
      border:1px solid rgba(36,48,66,.95);
    }
    .bar{height:100%; width:0%; background: linear-gradient(90deg, rgba(96,165,250,.95), rgba(52,211,153,.85));}
    .bar.warn{background: linear-gradient(90deg, rgba(251,191,36,.95), rgba(251,113,133,.85));}
    .small{font-size:12px; color:var(--muted)}
    .tabs{display:flex; gap:8px; flex-wrap:wrap}
    .tabbtn{
      padding:8px 10px;
      border-radius:999px;
      border:1px solid rgba(36,48,66,.75);
      background: rgba(17,24,39,.55);
      color:var(--text);
      cursor:pointer;
      font-size:12px;
      transition: .15s transform ease, .15s background ease;
    }
    .tabbtn:hover{transform: translateY(-1px); background: rgba(17,24,39,.75)}
    .tabbtn.active{border-color: rgba(96,165,250,.8); box-shadow: 0 0 0 2px rgba(96,165,250,.12) inset}
    .btn{
      display:inline-flex; align-items:center; justify-content:center; gap:8px;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(36,48,66,.8);
      background: rgba(31,41,55,.65);
      color:var(--text);
      cursor:pointer;
      font-size:12px;
      font-weight:600;
      transition: .15s transform ease, .15s background ease, .15s border ease;
      user-select:none;
    }
    .btn:hover{transform: translateY(-1px); background: rgba(31,41,55,.85)}
    .btn:active{transform: translateY(0px)}
    .btn.primary{background: rgba(96,165,250,.22); border-color: rgba(96,165,250,.75)}
    .btn.good{background: rgba(52,211,153,.18); border-color: rgba(52,211,153,.65)}
    .btn.warn{background: rgba(251,191,36,.15); border-color: rgba(251,191,36,.55)}
    .btn.bad{background: rgba(251,113,133,.15); border-color: rgba(251,113,133,.55)}
    .btn:disabled{opacity:.5; cursor:not-allowed; transform:none}
    .btnrow{display:flex; gap:10px; flex-wrap:wrap}
    .split{
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap:12px;
    }
    .field{
      display:flex; flex-direction:column; gap:6px;
    }
    label{font-size:12px; color:var(--muted)}
    select,input[type="number"],input[type="text"]{
      padding:10px 10px;
      border-radius:12px;
      border:1px solid rgba(36,48,66,.85);
      background: rgba(11,18,32,.6);
      color:var(--text);
      outline:none;
      font-size:12px;
    }
    input[type="checkbox"]{transform: translateY(1px)}
    .checkline{display:flex; gap:10px; flex-wrap:wrap}
    .check{
      display:flex; align-items:center; gap:8px;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid rgba(36,48,66,.65);
      background: rgba(11,18,32,.45);
      font-size:12px;
      color:var(--text);
    }
    .muted{color:var(--muted)}
    .tag{
      display:inline-flex;
      padding:2px 8px;
      border-radius:999px;
      border:1px solid rgba(36,48,66,.65);
      font-size:11px;
      color:var(--muted);
      background: rgba(11,18,32,.45);
    }
    .tag.good{border-color: rgba(52,211,153,.6); color: rgba(52,211,153,.95)}
    .tag.warn{border-color: rgba(251,191,36,.6); color: rgba(251,191,36,.95)}
    .tag.bad{border-color: rgba(251,113,133,.6); color: rgba(251,113,133,.95)}
    .hr{height:1px; background: rgba(36,48,66,.65); margin:12px 0}
    .log{
      display:flex; flex-direction:column; gap:8px;
      max-height: 680px;
      overflow:auto;
      padding-right:6px;
    }
    .log::-webkit-scrollbar{width:8px}
    .log::-webkit-scrollbar-thumb{background: rgba(36,48,66,.8); border-radius:999px}
    .entry{
      border:1px solid rgba(36,48,66,.75);
      background: rgba(11,18,32,.55);
      border-radius:14px;
      padding:10px 10px;
      line-height:1.45;
      font-size:12px;
    }
    .entry .meta{display:flex; gap:8px; align-items:center; justify-content:space-between; margin-bottom:6px}
    .entry .meta .t{font-family:var(--mono); font-size:11px; color:var(--muted)}
    .entry .meta .k{display:flex; gap:6px; align-items:center}
    .entry .meta .k .tag{font-size:10px}
    .entry .txt{white-space:pre-wrap}
    .pager{display:flex; gap:10px; align-items:center; justify-content:space-between; margin-top:10px}
    .pager .btn{padding:8px 10px}
    .modalWrap{
      position:fixed; inset:0;
      background: rgba(0,0,0,.55);
      display:none;
      align-items:center;
      justify-content:center;
      padding:18px;
      z-index: 50;
    }
    .modal{
      width:min(860px, 96vw);
      border-radius: 18px;
      background: rgba(17,24,39,.92);
      border:1px solid rgba(36,48,66,.85);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .modal .hd{padding:14px; border-bottom:1px solid rgba(36,48,66,.7); display:flex; align-items:center; justify-content:space-between; gap:10px}
    .modal .hd h3{margin:0; font-size:13px}
    .modal .bd{padding:14px}
    .modal .ft{padding:14px; border-top:1px solid rgba(36,48,66,.7); display:flex; gap:10px; justify-content:flex-end; flex-wrap:wrap}
    .cols2{display:grid; grid-template-columns: 1fr 1fr; gap:12px}
    .mono{font-family:var(--mono)}
    .danger{color: var(--bad)}
    .goodtxt{color: var(--good)}
    .warntxt{color: var(--warn)}
    @media (max-width: 1100px){
      .app{grid-template-columns: 1fr; }
      .topbar{flex-direction:column; align-items:flex-start}
    }
  

/* === Map Grid === */
.mapWrap{display:flex; gap:12px; flex-wrap:wrap}
.grid{display:grid; grid-template-columns: repeat(var(--n), 26px); grid-auto-rows:26px; gap:4px; padding:8px; background:rgba(255,255,255,.04); border:1px solid rgba(255,255,255,.10); border-radius:14px; overflow:auto; max-width:100%}
.tile{width:26px; height:26px; border-radius:8px; display:flex; align-items:center; justify-content:center; font-size:12px; cursor:pointer; user-select:none; border:1px solid rgba(255,255,255,.10); background:rgba(255,255,255,.03)}
.tile.unknown{opacity:.35}
.tile.you{outline:2px solid rgba(255,255,255,.55)}
.tile.poi{background:rgba(255,255,255,.06)}
.legend{display:flex; flex-wrap:wrap; gap:8px}
.badge{padding:4px 8px; border-radius:999px; border:1px solid rgba(255,255,255,.10); background:rgba(255,255,255,.04); font-size:12px}
.list{display:flex; flex-direction:column; gap:8px}
.itemRow{display:flex; gap:10px; align-items:flex-start; justify-content:space-between; padding:10px; border:1px solid rgba(255,255,255,.10); border-radius:14px; background:rgba(255,255,255,.03)}
.itemRow b{font-weight:700}
.itemMeta{display:flex; gap:8px; flex-wrap:wrap}
.pill2{padding:2px 8px; border-radius:999px; border:1px solid rgba(255,255,255,.10); background:rgba(255,255,255,.04); font-size:12px}
.mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}

</style>
</head>
<body>

  <div class="topbar">
    <div class="brand">
      <div class="logo" aria-hidden="true"></div>
      <div>
        <h1>修真RPG · 时光与寿元</h1>
        <div class="sub">修炼变慢、选择更重；十年闭关主要代价是错过机缘。五洲：东南西北中。</div>
      </div>
    </div>
    <div class="row">
      <div class="pill"><span>当前：</span><b id="nowText">—</b></div>
      <div class="pill"><span>地点：</span><b id="locText">—</b></div>
      <div class="pill"><span>寿元：</span><b id="lifeText">—</b></div>
      <button class="btn" id="btnSave">保存</button>
      <button class="btn" id="btnExport">导出</button>
      <button class="btn" id="btnImport">导入</button>
      <button class="btn" id="btnReset">重开</button>
    </div>
  </div>

  <div class="app">
    <!-- Left -->
    <section class="panel" id="panelChar">
      <div class="hd">
        <div>
          <h2>角色面板</h2>
          <div class="hint" id="charHint">—</div>
        </div>
        <span class="tag" id="tagAlign">—</span>
      </div>
      <div class="bd">
        <div class="card">
          <div class="kv"><span>境界</span><b id="realmText">—</b></div>
          <div style="margin-top:10px">
            <div class="small" style="display:flex; justify-content:space-between; gap:10px">
              <span>修为进度</span><span class="mono" id="xpText">—</span>
            </div>
            <div class="progress" style="margin-top:6px"><div class="bar" id="xpBar"></div></div>
          </div>
          <div style="margin-top:10px">
            <div class="small" style="display:flex; justify-content:space-between; gap:10px">
              <span>主修功法</span><span class="mono" id="techText">—</span>
            </div>
            <div class="progress" style="margin-top:6px"><div class="bar" id="techBar"></div></div>
          </div>
          <div style="margin-top:10px">
            <div class="small" style="display:flex; justify-content:space-between; gap:10px">
              <span>气血</span><span class="mono" id="hpText">—</span>
            </div>
            <div class="progress" style="margin-top:6px"><div class="bar warn" id="hpBar"></div></div>
          </div>
        </div>

        <div class="hr"></div>

        <div class="statgrid">
          <div class="kv"><span>灵石</span><b id="stoneText">—</b></div>
          <div class="kv"><span>悟性点</span><b id="insText">—</b></div>
          <div class="kv"><span>攻击</span><b id="atkText">—</b></div>
          <div class="kv"><span>防御</span><b id="defText">—</b></div>
          <div class="kv"><span>身法</span><b id="agiText">—</b></div>
          <div class="kv"><span>心境</span><b id="mindText">—</b></div>
        </div>

        <div class="hr"></div>

        <div class="card">
          <div class="small" style="display:flex; justify-content:space-between; gap:10px">
            <span>状态</span><span class="mono" id="statusText">—</span>
          </div>
          <div class="small" style="margin-top:8px; line-height:1.6" id="statusDesc">—</div>
        </div>
      </div>
    </section>

    <!-- Middle -->
    <section class="panel" id="panelMain">
      <div class="hd">
        <div>
          <h2>行动</h2>
          <div class="hint" id="mainHint">请选择一个行动页签。</div>
        </div>
        <div class="tabs" id="tabs"></div>
      </div>
      <div class="bd" id="mainBody"></div>
    </section>

    <!-- Right -->
    <section class="panel" id="panelLog">
      <div class="hd">
        <div>
          <h2>事件日志</h2>
          <div class="hint">最新在上。支持分页，避免日志过长影响体验。</div>
        </div>
        <div class="row">
          <button class="btn" id="btnClearLog">清空</button>
        </div>
      </div>
      <div class="bd">
        <div class="card">
          <div class="small">世界窗口预告（未来12个月）</div>
          <div class="small" style="margin-top:8px; line-height:1.55" id="upcomingText">—</div>
        </div>
        <div class="hr"></div>
        <div class="log" id="logList"></div>
        <div class="pager">
          <button class="btn" id="btnPrev">上一页</button>
          <div class="small mono" id="pageInfo">—</div>
          <button class="btn" id="btnNext">下一页</button>
        </div>
      </div>
    </section>
  </div>

  <!-- Modal -->
  <div class="modalWrap" id="modalWrap" role="dialog" aria-modal="true">
    <div class="modal">
      <div class="hd">
        <h3 id="modalTitle">—</h3>
        <button class="btn" id="modalClose">关闭</button>
      </div>
      <div class="bd" id="modalBody"></div>
      <div class="ft" id="modalFoot"></div>
    </div>
  </div>


<script>

/* 修真RPG · 时光与寿元 (v0.2) */
(()=>{"use strict";

/* =========================
   Config
========================= */
const VERSION = "0.2.0";
const SAVE_KEY = "xiuxian_rpg_save_v02";
const DAYS_PER_YEAR = 360;

const REALMS = [
  { name:"炼气", stages:["初期","中期","后期"], lifeCapYears: 90,  lifeGainYears: 0,   rejuvenateYears: 0  },
  { name:"筑基", stages:["初期","中期","后期"], lifeCapYears: 150, lifeGainYears: 60,  rejuvenateYears: 30 },
  { name:"金丹", stages:["初期","中期","后期"], lifeCapYears: 270, lifeGainYears: 120, rejuvenateYears: 60 },
  { name:"元婴", stages:["初期","中期","后期"], lifeCapYears: 470, lifeGainYears: 200, rejuvenateYears: 100},
  { name:"化神", stages:["初期","中期","后期"], lifeCapYears: 770, lifeGainYears: 300, rejuvenateYears: 150},
];

const TIER_LABEL = { t1:"一流", t2:"二流", t3:"三流" };
const ALIGN_LABEL = { righteous:"正道", neutral:"中立", evil:"魔道" };

const CONTINENTS = [
  { id:"east",  name:"东大陆",  desc:"山河秀丽，灵脉中等，资源均衡。",  mods:{res:1.0, risk:1.0, price:1.0}},
  { id:"south", name:"南大陆",  desc:"湿热繁茂，灵草丰富，妖兽也多。",  mods:{res:1.2, risk:1.1, price:1.0}},
  { id:"west",  name:"西大陆",  desc:"贫瘠匮乏，矿脉稀少，争夺频繁。",  mods:{res:0.75, risk:1.15, price:1.15}},
  { id:"north", name:"北大陆",  desc:"严寒凛冽，修行艰苦，但出奇才。",  mods:{res:0.9, risk:1.1, price:1.05}},
  { id:"central",name:"中大陆", desc:"最富裕繁盛，一流宗门最多，机缘也多。", mods:{res:1.35, risk:1.0, price:0.95}},
];

const ENVIRONMENTS = [
  { id:"wild",  name:"野外洞府", eff:1.0, risk:1.0, costStone:0 },
  { id:"sect",  name:"宗门洞府", eff:1.2, risk:0.85, costStone:120 },
  { id:"ley",   name:"灵脉福地", eff:1.5, risk:0.9, costStone:260 },
];

const SUPPLIES = [
  { id:"none", name:"不使用", cost:0, mods:{} },
  { id:"assist", name:"助修丹", cost:120, mods:{cultEff:+0.20} },
  { id:"guard",  name:"护脉丹", cost:160, mods:{fireRiskMul:0.60} },
  { id:"ward",   name:"辟邪符", cost:160, mods:{demonRiskMul:0.60} },
  { id:"stabil", name:"巩固散", cost:220, mods:{failPenaltyMul:0.50} },
];

const DEMON_POLICY = [
  { id:"confront", name:"直面心魔", desc:"悟性收益更高，失败代价更大。", mods:{insOnWin: +8, loseMul:1.1} },
  { id:"suppress", name:"压制心魔", desc:"失败代价更低，但收益较小。", mods:{insOnWin: +3, loseMul:0.85} },
  { id:"evade",    name:"回避心魔", desc:"更安全，但可能留下心魔印记。", mods:{insOnWin: 0,  markChance:+0.18} },
];

const AGENT_TASKS = [
  { id:"none", name:"不指派", desc:"—", mods:{} },
  { id:"intel", name:"打探机缘", desc:"降低错过窗口的损失。", mods:{missMitigation:+0.20} },
  { id:"buy",   name:"代购材料", desc:"闭关结束获得少量突破材料/灵石。", mods:{bonusStone:+120} },
  { id:"sect",  name:"维系宗门", desc:"闭关期间保持宗门贡献/名声缓慢增长。", mods:{sectContrib:+40} },
];

const ITEM_RARITY = [
  { id:"common",  name:"凡品", mult:1.0, color:"#ddd" },
  { id:"rare",    name:"灵品", mult:1.35 },
  { id:"epic",    name:"宝品", mult:1.75 },
  { id:"legend",  name:"仙品", mult:2.3 },
];

const ITEM_SLOTS = [
  { id:"weapon", name:"武器" },
  { id:"armor", name:"护具" },
  { id:"acc", name:"饰品" },
];

const TECHNIQUES = [
  { id:"qi_basic", name:"吐纳诀", style:"心法", desc:"稳扎稳打，适合入门。", mods:{cultEff:1.0, insEff:1.0, riskMul:0.95, atkMul:1.0, defMul:1.0}},
  { id:"sword",    name:"青锋剑典", style:"剑法", desc:"攻势凌厉，突破偏激进。", mods:{cultEff:0.98, insEff:1.05, riskMul:1.05, atkMul:1.12, defMul:0.95}},
  { id:"body",     name:"铁骨炼体", style:"体修", desc:"更耐打，走火概率略降。", mods:{cultEff:0.97, insEff:0.98, riskMul:0.90, atkMul:1.03, defMul:1.12}},
  { id:"mind",     name:"静心观想", style:"神魂", desc:"悟性更高，心魔更稳。", mods:{cultEff:0.96, insEff:1.22, riskMul:0.92, atkMul:0.95, defMul:1.02}},
];

/* =========================
   Utilities
========================= */
function $(id){ return document.getElementById(id); }
function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
function rand(){ return Math.random(); }
function randi(a,b){ return Math.floor(a + rand()*(b-a+1)); }
function pick(arr){ return arr[randi(0, arr.length-1)]; }
function fmt(n){ return Math.floor(n).toString(); }
function percent(x){ return `${Math.round(x*100)}%`; }

function hashStr(str){
  // simple deterministic hash
  let h=2166136261>>>0;
  for(let i=0;i<str.length;i++){
    h ^= str.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return h>>>0;
}
function mulberry32(a){
  return function(){
    let t = a += 0x6D2B79F5;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  }
}
function withSeed(seed, fn){
  const oldRand = Math.random;
  const gen = mulberry32(seed>>>0);
  Math.random = gen;
  try{ return fn(); } finally { Math.random = oldRand; }
}

function pushLog(state, who, msg, type="info"){
  const t = dateText(state);
  state.log.unshift({ t, who, msg, type });
  // keep log reasonable
  if(state.log.length>800) state.log.length = 800;
}

function getYear(state){ return Math.floor(state.time.dayAbs / DAYS_PER_YEAR) + 1; }
function getDayOfYear(state){ return (state.time.dayAbs % DAYS_PER_YEAR) + 1; }
function dateText(state){ return `第${getYear(state)}年·第${getDayOfYear(state)}日`; }

function ageYears(state){ return state.player.life.ageDays / DAYS_PER_YEAR; }
function lifeLeftDays(state){ return state.player.life.capDays - state.player.life.ageDays; }
function lifeText(state){
  const leftY = Math.max(0, lifeLeftDays(state)/DAYS_PER_YEAR);
  const capY = state.player.life.capDays / DAYS_PER_YEAR;
  return `剩余${leftY.toFixed(1)}年 / 上限${capY.toFixed(0)}年`;
}

function realmText(p){
  const r = REALMS[p.realmIdx];
  return `${r.name}·${r.stages[p.stageIdx]}`;
}

function alignLabel(v){
  if(v>=25) return "正道";
  if(v<=-25) return "魔道";
  return "中立";
}

/* =========================
   Economy & scaling
========================= */
function stagePower(realmIdx, stageIdx){
  // coarse power index
  return realmIdx*3 + stageIdx;
}
function xpNeed(realmIdx, stageIdx){
  // curve tuned for slower pace: each stage increases sharply
  const k = stagePower(realmIdx, stageIdx);
  return Math.floor(180 + 120*k + 55*k*k);
}

function baseStatsFor(realmIdx, stageIdx){
  const k = stagePower(realmIdx, stageIdx);
  return {
    atk: 8 + Math.floor(k*4.2),
    def: 6 + Math.floor(k*3.8),
    agi: 6 + Math.floor(k*3.2),
    mind: 6 + Math.floor(k*3.6),
    hp:  50 + Math.floor(k*22),
  };
}

/* =========================
   Items & Techniques
========================= */
function rarityByPower(k){
  const roll = rand();
  if(k>=10 && roll<0.06) return "legend";
  if(k>=6  && roll<0.14) return "epic";
  if(roll<0.32) return "rare";
  return "common";
}

function genItem(state, source="wild"){
  const p = state.player;
  const cont = getContinent(state);
  const k = stagePower(p.realmIdx, p.stageIdx);
  const rar = rarityByPower(k);
  const rarObj = ITEM_RARITY.find(x=>x.id===rar);
  const slot = pick(ITEM_SLOTS).id;

  const mult = rarObj.mult * (cont.mods.res);
  const base = {
    weapon: {atk: 6, def:0, agi:0, mind:0},
    armor:  {atk: 0, def:6, agi:0, mind:0},
    acc:    {atk: 0, def:0, agi:4, mind:4},
  }[slot];

  const roll = ()=> Math.max(0, Math.floor((base.atk + randi(0,2) + k*0.9) * mult));
  const rollD = ()=> Math.max(0, Math.floor((base.def + randi(0,2) + k*0.8) * mult));
  const rollA = ()=> Math.max(0, Math.floor((base.agi + randi(0,2) + k*0.6) * mult));
  const rollM = ()=> Math.max(0, Math.floor((base.mind + randi(0,2) + k*0.6) * mult));

  const stats = { atk: roll(), def: rollD(), agi: rollA(), mind: rollM() };

  // small modifiers
  let modText = "";
  let extra = {};
  if(rand()<0.25){
    extra.cultEff = +(0.02 + rand()*0.05).toFixed(3); // +2%..7%
    modText += `修炼效率+${Math.round(extra.cultEff*100)}% `;
  }
  if(rand()<0.18){
    extra.riskMul = +(0.90 + rand()*0.09).toFixed(3); // 0.90..0.99
    modText += `闭关风险×${extra.riskMul.toFixed(2)} `;
  }

  const nameCore = {
    weapon:["飞剑","长刀","枪","拂尘","匕首"],
    armor:["法衣","护甲","护腕","护肩","战袍"],
    acc:["玉佩","戒","护符","项坠","灵珠"],
  }[slot];
  const prefix = rar==="common" ? "" : rar==="rare" ? "灵" : rar==="epic" ? "宝" : "仙";
  const name = `${prefix}${pick(nameCore)}`;

  const price = Math.floor((80 + k*30) * rarObj.mult * cont.mods.price);
  const id = `itm_${Date.now()}_${Math.floor(Math.random()*1e6)}`;

  return {
    id, slot, rarity:rar, name,
    stats, extra,
    price,
    desc: modText.trim() || "—",
    source
  };
}

function getTechById(id){ return TECHNIQUES.find(t=>t.id===id); }

function ensurePlayerTechs(p){
  if(!p.techs) p.techs = { mainId:"qi_basic", known:{ qi_basic: { mastery:120 } } };
  if(!p.techs.mainId) p.techs.mainId = "qi_basic";
  if(!p.techs.known) p.techs.known = { qi_basic:{mastery:120} };
  if(!p.techs.known["qi_basic"]) p.techs.known["qi_basic"]={mastery:120};
}

function learnRandomTechnique(state, bias="any"){
  const p = state.player;
  ensurePlayerTechs(p);
  const knownIds = new Set(Object.keys(p.techs.known));
  const pool = TECHNIQUES.filter(t=>!knownIds.has(t.id));
  if(!pool.length) return null;
  const t = pick(pool);
  p.techs.known[t.id] = { mastery: 20 };
  return t;
}

/* =========================
   Continents & Map
========================= */
function getContinent(state){
  return CONTINENTS.find(c=>c.id===state.player.world.contId) || CONTINENTS[0];
}

function genNames(n, theme){
  const a = ["玄","青","太","天","灵","紫","赤","苍","归","真","太一","无相","星","月","霜","炎","金","玉","玄元","道"];
  const b = ["霄","云","剑","丹","冥","阳","阴","雷","泉","山","海","风","雪","火","木","砂","沙","河","城","宫","阁","宗"];
  const c = ["门","派","宫","宗","阁","观","殿"];
  const out = [];
  while(out.length<n){
    const nm = pick(a)+pick(b)+(rand()<0.6?pick(c):"");
    if(!out.includes(nm)) out.push(nm);
  }
  return out;
}

function genContinentMap(contId, year){
  // deterministic per year for "world evolves slowly"; but keep stable within a save
  const seed = hashStr(`${contId}_${year}_map_seed`);
  return withSeed(seed, ()=>{
    const size = 11; // manageable grid
    const tiles = [];
    for(let y=0;y<size;y++){
      for(let x=0;x<size;x++){
        tiles.push({ x,y, discovered:false, type:"wild", poi:null });
      }
    }
    const at = (x,y)=> tiles[y*size+x];
    const place = (x,y,type,poi)=>{ const t=at(x,y); t.type=type; t.poi=poi||null; };

    // terrain distribution hint by continent
    const cont = CONTINENTS.find(c=>c.id===contId);
    const scarcity = contId==="west" ? 0.35 : contId==="central" ? 0.65 : 0.5;
    const cold = contId==="north" ? 0.6 : 0.2;

    // basic randomness for wild tiles meta (stored in poi)
    for(const t of tiles){
      // precompute tile flavor
      const r = rand();
      let biome = "平原";
      if(r < 0.16 + cold*0.12) biome="雪原";
      else if(r < 0.30) biome="山地";
      else if(r < 0.42 + (1-scarcity)*0.10) biome="荒地";
      else if(r < 0.58 + (contId==="south"?0.10:0)) biome="密林";
      else if(r < 0.66) biome="丘陵";
      t.poi = t.poi || {};
      t.poi.biome = biome;
    }

    // POIs: cities, ruins, ports
    const cityCount = contId==="central" ? 3 : 2;
    for(let i=0;i<cityCount;i++){
      let x,y;
      do{ x=randi(1,size-2); y=randi(1,size-2); }while(at(x,y).type!=="wild");
      place(x,y,"city",{ name: pick(["安宁城","灵泉坊","青石镇","云河集","天枢城","落霞城"]), kind:"city" });
    }

    const ruinCount = contId==="central" ? 3 : 2;
    for(let i=0;i<ruinCount;i++){
      let x,y;
      do{ x=randi(1,size-2); y=randi(1,size-2); }while(at(x,y).type!=="wild");
      place(x,y,"ruin",{ name: pick(["古遗迹","残阵洞府","断剑冢","封印谷","秘泉窟"]), kind:"ruin" });
    }

    // ports: allow continent travel
    let px,py;
    do{ px=randi(0,size-1); py=randi(0,size-1); }while(at(px,py).type!=="wild");
    place(px,py,"port",{ name:"渡界港", kind:"port" });

    return { contId, size, tiles, generatedYear: year };
  });
}

/* =========================
   Sects generation
========================= */
function genSectsForAllContinents(state){
  const y = getYear(state);
  const all = [];
  const poolNames = genNames(60, "sect");
  let idx=0;
  const tierCounts = (contId)=>({
    t1: contId==="central" ? randi(5,6) : randi(2,3),
    t2: contId==="central" ? randi(4,6) : randi(3,5),
    t3: contId==="central" ? randi(4,6) : randi(3,6),
  });

  for(const cont of CONTINENTS){
    const counts = withSeed(hashStr(`${cont.id}_${y}_sect_seed`), ()=>tierCounts(cont.id));
    for(const tier of ["t1","t2","t3"]){
      for(let i=0;i<counts[tier];i++){
        const name = poolNames[idx++ % poolNames.length];
        const alignRoll = rand();
        const align = alignRoll<0.45 ? "righteous" : alignRoll<0.70 ? "neutral" : "evil";
        const id = `sect_${cont.id}_${tier}_${i}_${y}`;
        all.push({
          id, name, tier, align,
          contId: cont.id,
          fameReq: tier==="t1" ? 120 : tier==="t2" ? 60 : 0,
          realmReq: tier==="t1" ? 2 : tier==="t2" ? 1 : 0, // t1>=金丹, t2>=筑基, t3>=炼气
          joinFee: tier==="t1" ? 800 : tier==="t2" ? 400 : 120,
          libraryTechChance: tier==="t1" ? 0.75 : tier==="t2" ? 0.55 : 0.30,
          envUnlock: tier==="t1" ? "ley" : tier==="t2" ? "sect" : "wild",
          desc: `${TIER_LABEL[tier]}宗门·${ALIGN_LABEL[align]}｜${cont.name}`
        });
      }
    }
  }
  state.world.sects = all;
}

function placeSectsOnMaps(state){
  // place sect POIs on each continent map deterministically
  const year = getYear(state);
  state.world.maps = state.world.maps || {};
  for(const cont of CONTINENTS){
    if(!state.world.maps[cont.id]){
      state.world.maps[cont.id] = genContinentMap(cont.id, year);
    }
    const map = state.world.maps[cont.id];
    // clear existing sect marks
    for(const t of map.tiles){
      if(t.type==="sect") { t.type="wild"; t.poi=null; }
    }
    const sects = (state.world.sects||[]).filter(s=>s.contId===cont.id);
    const seed = hashStr(`${cont.id}_${year}_sect_place`);
    withSeed(seed, ()=>{
      const size = map.size;
      const at = (x,y)=> map.tiles[y*size+x];
      const used = new Set();
      function free(x,y){ const k=`${x},${y}`; return !used.has(k) && at(x,y).type==="wild"; }
      for(const s of sects){
        let x,y, tries=0;
        do{ x=randi(0,size-1); y=randi(0,size-1); tries++; }while((!free(x,y)) && tries<200);
        used.add(`${x},${y}`);
        const tile = at(x,y);
        tile.type="sect";
        tile.poi = { kind:"sect", sectId:s.id, name:s.name, tier:s.tier, align:s.align };
        s.pos = { x,y };
      }
    });
  }
}

/* =========================
   World windows (opportunities)
========================= */
function ensureWindowsForYear(state, year){
  // generate windows per continent; keep stable
  state.world.windows = state.world.windows || [];
  if(state.world.lastWindowGenYear >= year) return;

  const startAbs = (year-1)*DAYS_PER_YEAR;
  const endAbs   = year*DAYS_PER_YEAR - 1;
  const types = [
    { id:"secret", name:"秘境开启", dur:[30,90] },
    { id:"auction",name:"拍卖会", dur:[10,30] },
    { id:"recruit",name:"宗门大比/收徒", dur:[20,60] },
    { id:"rumor",  name:"机缘传闻", dur:[15,45] },
  ];

  for(const cont of CONTINENTS){
    const baseN = cont.id==="central" ? 5 : 3;
    const seed = hashStr(`${cont.id}_${year}_win_seed`);
    withSeed(seed, ()=>{
      for(let i=0;i<baseN;i++){
        const tp = pick(types);
        const len = randi(tp.dur[0], tp.dur[1]);
        const s = randi(startAbs, endAbs-len);
        const e = s + len;
        const id = `win_${cont.id}_${year}_${i}`;
        const name = tp.id==="secret" ? pick(["青冥秘境","归墟裂隙","天池洞天","万骨古窟"]) :
                     tp.id==="auction"? pick(["云河拍卖","万宝会","暗市竞拍"]) :
                     tp.id==="recruit"? pick(["宗门大比","内门考核","长老收徒"]) :
                     pick(["残卷线索","古图流出","散修传闻"]);
        state.world.windows.push({
          id, type:tp.id, typeName:tp.name, name,
          contId: cont.id,
          startAbs:s, endAbs:e,
          desc: `${cont.name}｜${tp.name}：${name}`,
          claimedBy:null,
        });
      }
    });
  }

  state.world.lastWindowGenYear = year;
}

function upcomingWindows(state, withinDays=360){
  const now = state.time.dayAbs;
  const end = now + withinDays;
  return (state.world.windows||[])
    .filter(w=>w.endAbs>=now && w.startAbs<=end)
    .sort((a,b)=>a.startAbs-b.startAbs);
}

/* =========================
   Game state & migration
========================= */
function defaultPlayer(){
  const startYear=1, startDay=1;
  const dayAbs=(startYear-1)*DAYS_PER_YEAR+(startDay-1);
  return {
    version: VERSION,
    time: { dayAbs, startDayAbs: dayAbs },
    player: {
      name:"无名散修",
      align: 0,
      realmIdx:0,
      stageIdx:0,
      xp:0,
      xpNeed: xpNeed(0,0),
      insight: 0,
      stones: 320,
      hp: 50, hpMax: 50,
      status: { wound:0, inner:0, demonMark:0, unstableDays:0 },
      world: { contId:"east", x:5, y:5, loc:"野外" },
      life: { ageDays: 18*DAYS_PER_YEAR, capDays: REALMS[0].lifeCapYears*DAYS_PER_YEAR },
      bag: { items:[], equip:{ weapon:null, armor:null, acc:null }, stabilizePow:0 },
      sect: { joined:false, sectId:"", name:"", tier:"", align:"", fame:0, contrib:0 },
      techs: { mainId:"qi_basic", known:{ qi_basic:{ mastery:120 } } },
    },
    world: {
      maps: {},
      sects: [],
      windows: [],
      lastWindowGenYear: 0,
      npcs: { rivals: [] },
      lastChronicle: null,
    },
    ui: { tab:"cultivate", logPage:0, selectedTile:null },
    log: [],
  };
}

function migrateSave(obj){
  if(!obj || typeof obj!=="object") return null;
  // from previous versions: attempt best-effort
  if(!obj.version){
    obj.version="0.1.0";
  }
  // ensure required nodes
  if(!obj.player) return null;
  // upgrade bag
  obj.player.bag = obj.player.bag || {};
  if(!obj.player.bag.items) obj.player.bag.items=[];
  if(!obj.player.bag.equip) obj.player.bag.equip={weapon:null, armor:null, acc:null};

  // world setup
  obj.world = obj.world || {};
  obj.world.maps = obj.world.maps || {};
  obj.world.sects = obj.world.sects || [];
  obj.world.windows = obj.world.windows || [];
  obj.world.npcs = obj.world.npcs || {rivals:[]};
  obj.world.lastWindowGenYear = obj.world.lastWindowGenYear || 0;

  // player world coords
  obj.player.world = obj.player.world || { contId:"east", x:5, y:5, loc:"野外" };
  if(!obj.player.world.contId) obj.player.world.contId="east";
  if(typeof obj.player.world.x!=="number") obj.player.world.x=5;
  if(typeof obj.player.world.y!=="number") obj.player.world.y=5;

  // status
  obj.player.status = obj.player.status || { wound:0, inner:0, demonMark:0, unstableDays:0 };

  // techs
  ensurePlayerTechs(obj.player);

  obj.version = VERSION;
  return obj;
}

let STATE = null;

/* =========================
   Core recalculation
========================= */
function equippedStats(p){
  const eq = p.bag.equip;
  const items = p.bag.items;
  const byId = new Map(items.map(it=>[it.id,it]));
  const total = { atk:0, def:0, agi:0, mind:0, cultEff:0, riskMul:1 };
  for(const slot of ["weapon","armor","acc"]){
    const id = eq[slot];
    if(!id) continue;
    const it = byId.get(id);
    if(!it) continue;
    total.atk += it.stats.atk||0;
    total.def += it.stats.def||0;
    total.agi += it.stats.agi||0;
    total.mind += it.stats.mind||0;
    if(it.extra && it.extra.cultEff) total.cultEff += it.extra.cultEff;
    if(it.extra && it.extra.riskMul) total.riskMul *= it.extra.riskMul;
  }
  total.riskMul = +total.riskMul.toFixed(3);
  total.cultEff = +total.cultEff.toFixed(3);
  return total;
}

function techMods(p){
  ensurePlayerTechs(p);
  const base = getTechById(p.techs.mainId) || TECHNIQUES[0];
  const mastery = (p.techs.known[p.techs.mainId]?.mastery || 0);
  const m = 1 + clamp(mastery/1000, 0, 1)*0.18; // mastery gives up to +18% effect
  return {
    name: base.name,
    style: base.style,
    mastery,
    cultEff: base.mods.cultEff * m,
    insEff: base.mods.insEff * m,
    riskMul: base.mods.riskMul,
    atkMul: base.mods.atkMul,
    defMul: base.mods.defMul
  };
}

function recalcStats(state){
  const p = state.player;
  const base = baseStatsFor(p.realmIdx, p.stageIdx);
  const eq = equippedStats(p);
  const tm = techMods(p);

  p.atk = Math.floor((base.atk + eq.atk) * tm.atkMul);
  p.def = Math.floor((base.def + eq.def) * tm.defMul);
  p.agi = Math.floor(base.agi + eq.agi);
  p.mind= Math.floor(base.mind + eq.mind);
  p.hpMax = Math.floor(base.hp);
  p.hp = clamp(p.hp, 1, p.hpMax);

  // cultivation efficiency multiplier
  p._cultEffMul = (1 + eq.cultEff) * tm.cultEff;
  p._insEffMul  = tm.insEff;
  p._riskMulEq  = eq.riskMul * tm.riskMul;

  // alignment
  state.player._alignLabel = alignLabel(p.align);

  // location label
  p.world.loc = tileLocText(state);
}

function tileLocText(state){
  const map = getMap(state);
  const t = getTile(state, state.player.world.x, state.player.world.y);
  if(!t) return "未知";
  if(t.type==="city") return `城镇·${t.poi.name}`;
  if(t.type==="sect"){
    const s = state.world.sects.find(x=>x.id===t.poi.sectId);
    return `宗门·${s? s.name : "宗门"}`;
  }
  if(t.type==="ruin") return `遗迹·${t.poi.name}`;
  if(t.type==="port") return `港口·${t.poi.name}`;
  return `野外·${t.poi?.biome || "荒野"}`;
}

function getMap(state){
  state.world.maps = state.world.maps || {};
  const contId = state.player.world.contId;
  const year = getYear(state);
  if(!state.world.maps[contId]) state.world.maps[contId]=genContinentMap(contId, year);
  return state.world.maps[contId];
}
function getTile(state,x,y){
  const map=getMap(state);
  if(x<0||y<0||x>=map.size||y>=map.size) return null;
  return map.tiles[y*map.size+x];
}

/* =========================
   Combat (lightweight)
========================= */
function encounterDifficulty(state){
  const cont = getContinent(state);
  const base = stagePower(state.player.realmIdx, state.player.stageIdx);
  // region variance: 70% near, 20% lower, 10% higher
  const r = rand();
  let diff = base;
  if(r<0.20) diff = Math.max(0, base - randi(1,3));
  else if(r>0.90) diff = base + randi(2,4);
  else diff = clamp(base + randi(-1,1), 0, 99);
  // continent hardship
  diff = Math.round(diff * cont.mods.risk);
  return diff;
}

function resolveFight(state, diff){
  const p = state.player;
  const enemyAtk = 8 + diff*4;
  const enemyDef = 6 + diff*3;
  const enemyHp  = 40 + diff*20;
  const pPow = (p.atk*1.2 + p.def + p.agi*0.6 + p.mind*0.6);
  const ePow = (enemyAtk*1.1 + enemyDef + diff*8);
  const ratio = pPow / (ePow+1e-6);
  const winChance = clamp(0.35 + 0.25*Math.log(ratio+1), 0.05, 0.95);
  const roll = rand();
  if(roll < winChance){
    // win: maybe item, stones, insight
    const gainStone = randi(30, 80) + diff*12;
    const gainIns = randi(1,3) + Math.floor(diff/5);
    p.stones += gainStone;
    p.insight += gainIns;
    if(rand() < 0.28){
      const it = genItem(state, "battle");
      p.bag.items.push(it);
      pushLog(state, "战斗", `你击败对手（难度${diff}），战利品：+${gainStone}灵石，+${gainIns}悟性，并获得【${it.name}】。`, "good");
    }else{
      pushLog(state, "战斗", `你击败对手（难度${diff}），战利品：+${gainStone}灵石，+${gainIns}悟性。`, "good");
    }
  }else{
    // lose: wound, time loss, maybe stolen stones
    const wound = randi(10,25) + Math.floor(diff/2);
    p.status.wound += wound;
    const lost = Math.min(p.stones, randi(20,70)+diff*8);
    p.stones -= lost;
    // forced retreat consumes days
    advanceDays(state, randi(3,12), { silent:true });
    pushLog(state, "战斗", `你不敌对手（难度${diff}），受伤+${wound}，损失灵石-${lost}，且仓促撤离耗费数日。`, "bad");
  }
  normalizeStatus(state);
}

/* =========================
   Time advance, healing & windows
========================= */
function normalizeStatus(state){
  const p = state.player;
  p.status.wound = clamp(p.status.wound, 0, 9999);
  p.status.inner = clamp(p.status.inner, 0, 9999);
  p.status.demonMark = clamp(p.status.demonMark, 0, 9999);
  p.status.unstableDays = clamp(p.status.unstableDays, 0, 9999);
  // healing tick: daily
}

function tickDay(state){
  const p = state.player;
  p.life.ageDays += 1;
  // passive healing
  if(p.status.wound>0) p.status.wound -= 1;
  if(p.status.inner>0 && rand()<0.5) p.status.inner -= 1;
  if(p.status.unstableDays>0 && rand()<0.7) p.status.unstableDays -= 1;

  // if life ends
  if(lifeLeftDays(state)<=0){
    state._gameOver = true;
    pushLog(state, "系统", "寿元已尽，你的故事在此终结。", "bad");
  }
}

function advanceDays(state, days, opts={}){
  const silent=!!opts.silent;
  if(days<=0||state._gameOver) return;
  const startAbs = state.time.dayAbs;
  const endAbs = startAbs + days;

  for(let i=0;i<days;i++){
    state.time.dayAbs += 1;
    tickDay(state);
    if(state._gameOver) break;
    // generate windows for new year boundary
    const y = getYear(state);
    ensureWindowsForYear(state, y);
  }

  // discover current tile
  const tile = getTile(state, state.player.world.x, state.player.world.y);
  if(tile) tile.discovered = true;

  if(!silent){
    pushLog(state, "时光", `时光流逝：+${days}天。`, "info");
  }
  recalcStats(state);
}

function missWindowsBetween(state, aAbs, bAbs, mitigation=0){
  // summarize missed windows within period; claim by NPCs
  const wins = (state.world.windows||[]).filter(w=>w.startAbs>=aAbs && w.endAbs<=bAbs);
  const missed = [];
  for(const w of wins){
    // chance you still get partial via agent mitigation
    const effectiveMiss = clamp(1 - mitigation, 0, 1);
    if(rand() < effectiveMiss){
      // NPC claims
      const npc = genNpcClaim(state, w);
      w.claimedBy = npc;
      missed.push(w);
    }
  }
  return missed;
}

function genNpcClaim(state, w){
  const pool = ["散修","邪修","游侠","宗门弟子","商会"];
  const names = ["陆","沈","唐","秦","韩","楚","苏","叶","林","顾","夏","白","温","宁","纪"];
  const given = ["玄","青","岳","霜","炎","灵","澜","清","无尘","墨","烬","星河","归一"];
  const name = pick(names)+pick(given);
  const diff = randi(0,2);
  return { name, faction: pick(pool), diff };
}

/* =========================
   Cultivation / Retreat
========================= */
function baseRiskByDays(days){
  if(days<=30) return { fire:0.01, demon:0.02 };
  if(days<=360) return { fire:0.03, demon:0.05 };
  return { fire:0.06, demon:0.08 }; // 10y
}

function retreat(state, plan){
  const p = state.player;
  if(state._gameOver) return;

  const env = ENVIRONMENTS.find(e=>e.id===plan.envId) || ENVIRONMENTS[0];
  const supply = SUPPLIES.find(s=>s.id===plan.supplyId) || SUPPLIES[0];
  const policy = DEMON_POLICY.find(x=>x.id===plan.demonPolicyId) || DEMON_POLICY[0];
  const agent = AGENT_TASKS.find(a=>a.id===plan.agentId) || AGENT_TASKS[0];
  const days = plan.days;

  // pay cost
  const totalCost = env.costStone + supply.cost;
  if(p.stones < totalCost){
    pushLog(state, "系统", `灵石不足：需要${totalCost}，当前${p.stones}。`, "bad");
    return;
  }
  p.stones -= totalCost;

  // compute multipliers
  const woundPenalty = 1 - clamp(p.status.wound/220, 0, 0.45);
  const innerPenalty = 1 - clamp(p.status.inner/260, 0, 0.35);
  const unstablePenalty = 1 - (p.status.unstableDays>0 ? 0.18 : 0);

  const base = baseRiskByDays(days);
  let fireRisk = base.fire;
  let demonRisk = base.demon;

  // age penalty (older -> more demon risk)
  const age = ageYears(state);
  if(age>60) demonRisk += 0.02;
  if(age>90) demonRisk += 0.03;

  // alignment swing and demon mark
  demonRisk += clamp(p.status.demonMark/1200, 0, 0.12);

  // apply env/supply/policy/gear/tech
  const supplyMods = supply.mods || {};
  fireRisk *= (supplyMods.fireRiskMul || 1);
  demonRisk *= (supplyMods.demonRiskMul || 1);

  fireRisk *= env.risk;
  demonRisk *= env.risk;

  fireRisk *= p._riskMulEq;
  demonRisk *= p._riskMulEq;

  // ensure reasonable
  fireRisk = clamp(fireRisk, 0.002, 0.25);
  demonRisk = clamp(demonRisk, 0.004, 0.35);

  // XP gains
  const k = stagePower(p.realmIdx, p.stageIdx);
  const cont = getContinent(state);
  const timeEff = days<=30? 1.0 : days<=360? 1.1 : 1.12; // long retreat slightly steadier
  const cultGain = Math.floor(days * (1.2 + k*0.22) * env.eff * p._cultEffMul * woundPenalty * innerPenalty * unstablePenalty * timeEff);
  const techGain = Math.floor(days * (0.8 + k*0.12) * env.eff * (0.9 + p.mind/100) * timeEff);

  // insight gain: long retreat gives some, but main source is outside; still meaningful
  const baseIns = days<=30? 0 : days<=360? 2 : 6;
  const insGain = Math.floor((baseIns + Math.sqrt(days)/7) * cont.mods.res * p._insEffMul);

  // advance time day by day but without log spam
  const startAbs = state.time.dayAbs;
  advanceDays(state, days, { silent:true });
  const endAbs = state.time.dayAbs;

  if(state._gameOver) return;

  // apply gains
  p.xp += cultGain;
  p.insight += insGain;
  // technique mastery
  ensurePlayerTechs(p);
  const mainId = p.techs.mainId;
  p.techs.known[mainId].mastery = clamp((p.techs.known[mainId].mastery||0) + Math.floor(techGain/10), 0, 1000);

  // risks resolve (single roll per retreat)
  let hadFire=false, hadDemon=false;
  if(rand() < fireRisk){
    hadFire=true;
    const wound = randi(18,45) + Math.floor(k*1.2);
    p.status.wound += wound;
    p.status.inner += Math.floor(wound*0.6);
  }
  if(rand() < demonRisk){
    hadDemon=true;
    // resolve via policy: determine win/lose with mind vs k
    const diff = Math.max(0, k + (age>80?1:0) + (p.status.demonMark>0?1:0));
    const mindPow = p.mind + (p.insight/20);
    const chance = clamp(0.45 + (mindPow - diff*10)/120, 0.15, 0.85);
    const win = rand() < chance;
    if(win){
      p.insight += 6 + policy.mods.insOnWin;
      // reduce demon mark
      if(p.status.demonMark>0) p.status.demonMark = Math.max(0, p.status.demonMark - randi(4,10));
    }else{
      // penalty: mark or wound, scaled by policy
      const mul = policy.mods.loseMul || 1;
      const addMark = Math.round(randi(6,16)*mul);
      p.status.demonMark += addMark;
      p.status.wound += Math.round(randi(6,20)*mul);
      if(rand() < (policy.mods.markChance||0)){
        p.status.demonMark += randi(6,14);
      }
    }
  }

  // missed windows (for 10y mainly)
  let chronicle = null;
  if(days>=3600){
    const mitig = clamp(agent.mods.missMitigation||0, 0, 0.6);
    const missed = missWindowsBetween(state, startAbs, endAbs, mitig);
    const lines = [];
    lines.push(`【十年大事记】你闭关十年出关。修为精进，但世事更迭。`);
    if(agent.id!=="none"){
      lines.push(`代理人：${agent.name}（错过损失减免${Math.round(mitig*100)}%）。`);
    }
    if(missed.length===0){
      lines.push("这十年，你未明显错过关键窗口（或已被代理人妥善处理）。");
    }else{
      for(const w of missed.slice(0,10)){
        const npc = w.claimedBy;
        lines.push(`- ${w.desc}｜被${npc.faction}「${npc.name}」夺得先机。`);
        // create rival with small chance
        if(rand()<0.30){
          state.world.npcs.rivals.push({ name:npc.name, contId:w.contId, power: encounterDifficulty(state), hatred:randi(10,30) });
        }
      }
      if(missed.length>10) lines.push(`（还有${missed.length-10}条大事略过）`);
    }
    // agent bonus
    if(agent.mods.bonusStone) p.stones += agent.mods.bonusStone;
    if(agent.mods.sectContrib && p.sect.joined) p.sect.contrib += agent.mods.sectContrib;
    chronicle = lines.join("\n");
    state.world.lastChronicle = { startAbs, endAbs, text: chronicle };
  }else{
    // small agent bonuses for shorter retreats
    if(agent.mods.bonusStone && days>=360) p.stones += Math.floor(agent.mods.bonusStone*0.5);
    if(agent.mods.sectContrib && p.sect.joined && days>=360) p.sect.contrib += Math.floor(agent.mods.sectContrib*0.4);
  }

  // update xpNeed
  p.xpNeed = xpNeed(p.realmIdx, p.stageIdx);
  normalizeStatus(state);
  recalcStats(state);

  // log summary
  const riskNote = `走火${percent(fireRisk)}｜心魔${percent(demonRisk)}`;
  let msg = `闭关结算：+修为${cultGain}，+悟性${insGain}，主功法熟练提升。费用-${totalCost}灵石。风险：${riskNote}。`;
  if(hadFire) msg += "（触发走火：伤势加重）";
  if(hadDemon) msg += "（心魔来袭：已结算）";
  pushLog(state, "闭关", msg, hadFire||hadDemon ? "warn":"good");
  if(chronicle){
    pushLog(state, "纪元", chronicle.replace(/\n/g,"<br>"), "info_html");
  }
}

/* =========================
   Breakthrough
========================= */
function prepScore(state){
  const p = state.player;
  const map = getMap(state);
  const tile = getTile(state, p.world.x, p.world.y);
  let score = 0;
  // XP fullness
  const ratio = p.xp / (p.xpNeed||1);
  if(ratio>=1.15) score+=3;
  else if(ratio>=1.0) score+=2;
  else if(ratio>=0.85) score+=1;

  // technique mastery
  const mastery = techMods(p).mastery;
  if(mastery>=700) score+=2;
  else if(mastery>=350) score+=1;

  // insight reserve
  if(p.insight>=80) score+=2;
  else if(p.insight>=35) score+=1;

  // status penalties
  if(p.status.wound>40) score-=1;
  if(p.status.inner>35) score-=1;
  if(p.status.demonMark>30) score-=1;
  if(p.status.unstableDays>0) score-=1;

  // environment: sect tile or ley gives bonus
  if(tile && (tile.type==="sect"||tile.type==="city")) score+=1;

  // bag stabilizePow (from future items)
  if(p.bag.stabilizePow) score += Math.floor(p.bag.stabilizePow/20);

  score = clamp(score, 0, 9);
  const label = score<=2 ? "低" : score<=4 ? "中" : score<=6 ? "高" : "极高";
  return { score, label };
}

function successChanceFromPrep(prep){
  // tuned to "delay cost": low still possible but not comfortable
  const s = prep.score;
  if(s<=2) return { lo:0.25, hi:0.45 };
  if(s<=4) return { lo:0.45, hi:0.65 };
  if(s<=6) return { lo:0.65, hi:0.82 };
  return { lo:0.82, hi:0.93 };
}

function doBreakthrough(state, spendInsight=0, useStabil=false){
  const p = state.player;
  if(state._gameOver) return;
  // check if at max
  if(p.realmIdx>=REALMS.length-1 && p.stageIdx>=REALMS[p.realmIdx].stages.length-1){
    pushLog(state, "突破", "你已臻至此界极限（MVP上限）。", "info");
    return;
  }

  const prep = prepScore(state);
  const ch = successChanceFromPrep(prep);

  // use insight to boost within range
  const spend = clamp(spendInsight, 0, Math.min(p.insight, 120));
  p.insight -= spend;
  const boost = spend/200; // up to +60%? actually 120/200=0.6 but clamp later
  const stabMul = useStabil ? 0.6 : 1.0;

  let chance = clamp(ch.lo + (ch.hi-ch.lo)*0.55 + boost*0.20, 0.05, 0.98);
  // penalties
  chance -= clamp(p.status.demonMark/400, 0, 0.18);
  chance -= clamp(p.status.wound/500, 0, 0.12);
  chance -= (p.status.unstableDays>0 ? 0.10 : 0);

  chance = clamp(chance, 0.05, 0.98);

  const roll = rand();
  if(roll < chance){
    // success
    // advance stage or realm
    const oldRealm = p.realmIdx;
    const oldStage = p.stageIdx;
    if(p.stageIdx < REALMS[p.realmIdx].stages.length-1){
      p.stageIdx += 1;
    }else{
      p.realmIdx += 1;
      p.stageIdx = 0;
      // life cap and rejuvenation
      const cap = REALMS[p.realmIdx].lifeCapYears * DAYS_PER_YEAR;
      p.life.capDays = Math.max(p.life.capDays, cap);
      const rej = REALMS[p.realmIdx].rejuvenateYears * DAYS_PER_YEAR;
      p.life.ageDays = Math.max(0, p.life.ageDays - rej);
      pushLog(state, "寿元", `大境界突破：寿元上限提升至${REALMS[p.realmIdx].lifeCapYears}年，并回春${REALMS[p.realmIdx].rejuvenateYears}年。`, "good");
    }
    p.xp = Math.max(0, p.xp - Math.floor(p.xpNeed*0.95));
    p.xpNeed = xpNeed(p.realmIdx, p.stageIdx);
    // unstable period
    p.status.unstableDays = randi(12, 35) + p.realmIdx*8;
    pushLog(state, "突破", `突破成功：${realmText(p)}。进入巩固期（${p.status.unstableDays}天）。`, "good");
  }else{
    // fail: delay cost, gentle but meaningful
    const failKind = rand();
    const penaltyMul = stabMul;
    if(failKind < 0.45){
      // unstable -> longer
      const add = Math.round((randi(12, 28) + p.realmIdx*6) * penaltyMul);
      p.status.unstableDays += add;
      pushLog(state, "突破", `突破失败：气息紊乱，巩固期延长${add}天。`, "warn");
    }else if(failKind < 0.80){
      // wound
      const w = Math.round((randi(10, 24) + p.realmIdx*6) * penaltyMul);
      p.status.wound += w;
      pushLog(state, "突破", `突破失败：经脉受创，伤势+${w}。`, "warn");
    }else{
      // demon mark
      const m = Math.round((randi(8, 18) + p.realmIdx*4) * penaltyMul);
      p.status.demonMark += m;
      pushLog(state, "突破", `突破失败：心境不稳，心魔印记+${m}。`, "warn");
    }
    // some time passes
    advanceDays(state, randi(5,18), { silent:true });
  }

  normalizeStatus(state);
  recalcStats(state);
}

/* =========================
   Map actions
========================= */
function move(state, dx, dy){
  if(state._gameOver) return;
  const map = getMap(state);
  const nx = state.player.world.x + dx;
  const ny = state.player.world.y + dy;
  if(nx<0||ny<0||nx>=map.size||ny>=map.size){
    pushLog(state, "探索", "此路不通。", "info");
    return;
  }
  state.player.world.x = nx;
  state.player.world.y = ny;
  const tile = getTile(state, nx, ny);
  tile.discovered = true;
  // moving consumes 1-3 days depending on terrain
  const biome = tile.poi?.biome || "平原";
  let cost = 2;
  if(biome==="山地"||biome==="密林"||biome==="雪原") cost=3;
  if(tile.type==="city"||tile.type==="sect"||tile.type==="port") cost=1;
  advanceDays(state, cost, { silent:true });
  pushLog(state, "探索", `你前往新的区域（耗时${cost}天）：${tileLocText(state)}。`, "info");
  // chance encounter in wild/ruin
  if(tile.type==="wild" && rand()<0.22*getContinent(state).mods.risk){
    const diff = encounterDifficulty(state);
    pushLog(state, "遭遇", `野外遭遇不速之客（难度${diff}）。`, "warn");
    resolveFight(state, diff);
  }
  if(tile.type==="ruin" && rand()<0.45){
    exploreRuin(state);
  }
  recalcStats(state);
}

function exploreHere(state){
  const tile = getTile(state, state.player.world.x, state.player.world.y);
  if(!tile) return;
  if(tile.type==="city"){
    pushLog(state, "城镇", "你在城镇休整，补给齐全。可以购买装备/功法、疗伤、打听消息。", "good");
    // city rest heals
    const p=state.player;
    const days=3;
    advanceDays(state, days, { silent:true });
    p.status.wound = Math.max(0, p.status.wound - 12);
    p.status.inner = Math.max(0, p.status.inner - 10);
    pushLog(state, "城镇", `休整${days}天，伤势有所恢复。`, "good");
  }else if(tile.type==="sect"){
    const sect = state.world.sects.find(s=>s.id===tile.poi.sectId);
    if(!sect){ pushLog(state,"宗门","宗门信息缺失。","warn"); return; }
    pushLog(state, "宗门", `你来到${sect.name}（${TIER_LABEL[sect.tier]}·${ALIGN_LABEL[sect.align]}）。可尝试加入、接差事、翻阅藏经。`, "info");
  }else if(tile.type==="ruin"){
    exploreRuin(state);
  }else if(tile.type==="port"){
    pushLog(state, "港口", "此处可渡界前往其他大陆（耗时30天并支付费用）。", "info");
  }else{
    // wild exploration for resources
    const p=state.player;
    const cont=getContinent(state);
    const days=7;
    advanceDays(state, days, { silent:true });
    const gainStone = Math.floor((randi(20,60) + stagePower(p.realmIdx,p.stageIdx)*10) * cont.mods.res);
    const gainIns = Math.floor((randi(0,2) + (rand()<0.25?1:0)) * p._insEffMul);
    p.stones += gainStone;
    p.insight += gainIns;
    if(rand()<0.22*cont.mods.res){
      const it = genItem(state, "gather");
      p.bag.items.push(it);
      pushLog(state, "探索", `野外探索${days}天：+${gainStone}灵石，+${gainIns}悟性，并获得【${it.name}】。`, "good");
    }else{
      pushLog(state, "探索", `野外探索${days}天：+${gainStone}灵石，+${gainIns}悟性。`, "good");
    }
    if(rand()<0.18*cont.mods.risk){
      const diff=encounterDifficulty(state);
      pushLog(state, "遭遇", `探索途中遭遇敌人（难度${diff}）。`, "warn");
      resolveFight(state, diff);
    }
  }
  normalizeStatus(state);
  recalcStats(state);
}

function exploreRuin(state){
  const p=state.player;
  const cont=getContinent(state);
  const days=randi(7,18);
  advanceDays(state, days, { silent:true });
  const diff = encounterDifficulty(state) + randi(0,2);
  if(rand()<0.65){
    pushLog(state,"遗迹",`你在遗迹中触发守关（难度${diff}）。`,"warn");
    resolveFight(state, diff);
  }
  const gainIns = Math.floor((randi(3,8) + Math.floor(diff/6)) * p._insEffMul);
  p.insight += gainIns;
  const gainStone = Math.floor((randi(40,120) + diff*18) * cont.mods.res);
  p.stones += gainStone;
  // chance learn technique fragment
  if(rand()<0.22){
    const t = learnRandomTechnique(state);
    if(t){
      pushLog(state, "遗迹", `你从残卷中领悟新功法：【${t.name}】。`, "good");
    }
  }
  // loot
  const it = genItem(state, "ruin");
  p.bag.items.push(it);
  pushLog(state, "遗迹", `遗迹探索${days}天：+${gainStone}灵石，+${gainIns}悟性，获得【${it.name}】。`, "good");
}

/* =========================
   Sect actions
========================= */
function currentSectTile(state){
  const tile = getTile(state, state.player.world.x, state.player.world.y);
  if(tile && tile.type==="sect"){
    return state.world.sects.find(s=>s.id===tile.poi.sectId) || null;
  }
  return null;
}

function tryJoinCurrentSect(state){
  const p=state.player;
  const sect = currentSectTile(state);
  if(!sect){ pushLog(state,"宗门","你不在宗门驻地。","warn"); return; }
  if(p.sect.joined){
    pushLog(state,"宗门",`你已在${p.sect.name}修行。暂不支持同时加入多个宗门。`,"info");
    return;
  }
  if(p.realmIdx < sect.realmReq){
    pushLog(state,"宗门",`境界不足：${TIER_LABEL[sect.tier]}宗门要求至少${REALMS[sect.realmReq].name}。`,"bad");
    return;
  }
  const fame = p.sect.fame || 0;
  if(fame < sect.fameReq){
    pushLog(state,"宗门",`名望不足：需要${sect.fameReq}，当前${fame}。可通过探索/击败强敌/完成委托提升。`,"warn");
    return;
  }
  if(p.stones < sect.joinFee){
    pushLog(state,"宗门",`入门费不足：需要${sect.joinFee}灵石。`,"bad");
    return;
  }

  // alignment gate (soft): if too opposite, harder
  let gate = 0;
  const al = p.align;
  if(sect.align==="righteous" && al<-40) gate = 1;
  if(sect.align==="evil" && al>40) gate = 1;

  p.stones -= sect.joinFee;
  advanceDays(state, randi(7,18), { silent:true });
  const passChance = gate? 0.45 : 0.70;
  if(rand() < passChance){
    p.sect = { joined:true, sectId:sect.id, name:sect.name, tier:sect.tier, align:sect.align, fame:Math.max(p.sect.fame||0, sect.fameReq), contrib:0 };
    pushLog(state,"宗门",`你通过入门考核，正式加入【${sect.name}】。`,"good");
    // reward: maybe technique
    if(rand()<sect.libraryTechChance){
      const t = learnRandomTechnique(state);
      if(t) pushLog(state,"宗门",`藏经阁中，你习得【${t.name}】。`,"good");
    }
  }else{
    pushLog(state,"宗门",`入门考核失利。你被安排在外门历练一段时日。`,"warn");
    p.sect.fame = (p.sect.fame||0) + 10;
  }
  recalcStats(state);
}

function sectChore(state){
  const p=state.player;
  if(!p.sect.joined){ pushLog(state,"宗门","你尚未加入宗门。","warn"); return; }
  const days=30;
  advanceDays(state, days, { silent:true });
  const tier=p.sect.tier;
  const gain = tier==="t1"? 320 : tier==="t2"? 220 : 140;
  p.stones += gain;
  p.sect.contrib += tier==="t1"? 60 : tier==="t2"? 45 : 30;
  // fame
  p.sect.fame = (p.sect.fame||0) + 8;
  pushLog(state,"宗门",`你完成宗门差事${days}天：+${gain}灵石，贡献+${tier==="t1"?60:tier==="t2"?45:30}，名望小幅提升。`,"good");
  // chance learn technique in library
  if(rand()< (tier==="t1"?0.25:tier==="t2"?0.18:0.12)){
    const t=learnRandomTechnique(state);
    if(t) pushLog(state,"宗门",`你在差事间隙研读藏经，习得【${t.name}】。`,"good");
  }
  recalcStats(state);
}

function leaveSect(state){
  const p=state.player;
  if(!p.sect.joined){ pushLog(state,"宗门","你未加入宗门。","info"); return; }
  pushLog(state,"宗门",`你离开了【${p.sect.name}】。短期内名望会受影响。`,"warn");
  p.sect.joined=false;
  p.sect.sectId="";
  p.sect.name="";
  p.sect.tier="";
  p.sect.align="";
  p.sect.contrib=0;
  p.sect.fame = Math.max(0, (p.sect.fame||0)-30);
  recalcStats(state);
}

/* =========================
   Shop (city)
========================= */
function inCity(state){
  const t=getTile(state, state.player.world.x, state.player.world.y);
  return !!t && t.type==="city";
}
function buyRandomItem(state){
  if(!inCity(state)){ pushLog(state,"商会","你需要在城镇才能交易。","warn"); return; }
  const p=state.player;
  const it=genItem(state, "shop");
  const price=it.price;
  if(p.stones<price){
    pushLog(state,"商会",`灵石不足：需要${price}。`,"bad"); return;
  }
  p.stones-=price;
  p.bag.items.push(it);
  pushLog(state,"商会",`你购得【${it.name}】（${price}灵石）。`,"good");
  recalcStats(state);
}
function buyTechniqueScroll(state){
  if(!inCity(state)){ pushLog(state,"商会","你需要在城镇才能购买功法。","warn"); return; }
  const p=state.player;
  ensurePlayerTechs(p);
  const t = learnRandomTechnique(state);
  if(!t){
    pushLog(state,"商会","市面上暂时没有你未学过的功法。","info"); return;
  }
  const price = Math.floor((260 + stagePower(p.realmIdx,p.stageIdx)*40) * getContinent(state).mods.price);
  if(p.stones<price){
    // rollback learning if can't pay
    delete p.techs.known[t.id];
    pushLog(state,"商会",`灵石不足：购买功法需要${price}。`,"bad"); return;
  }
  p.stones-=price;
  pushLog(state,"商会",`你购得功法残卷并习得【${t.name}】（${price}灵石）。`,"good");
  recalcStats(state);
}

/* =========================
   Travel between continents
========================= */
function canTravelPort(state){
  const t=getTile(state, state.player.world.x, state.player.world.y);
  return t && t.type==="port";
}
function travelToContinent(state, targetId){
  if(!canTravelPort(state)){
    pushLog(state,"渡界","你需要在港口（渡界港）才能前往其他大陆。","warn"); return;
  }
  const p=state.player;
  const fee = Math.floor(420 * getContinent(state).mods.price);
  if(p.stones < fee){
    pushLog(state,"渡界",`灵石不足：渡界费用${fee}。`,"bad"); return;
  }
  p.stones -= fee;
  const days = 30;
  const from = getContinent(state).name;
  advanceDays(state, days, { silent:true });
  p.world.contId = targetId;
  // put at port of new continent
  const map = getMap(state);
  // find port tile
  const portTile = map.tiles.find(t=>t.type==="port") || map.tiles[0];
  p.world.x = portTile.x; p.world.y=portTile.y;
  portTile.discovered=true;
  pushLog(state,"渡界",`你从${from}渡界前往${CONTINENTS.find(c=>c.id===targetId).name}（耗时${days}天，费用${fee}）。`,"info");
  recalcStats(state);
}

/* =========================
   Inventory / Equipment actions
========================= */
function equipItem(state, itemId){
  const p=state.player;
  const it = p.bag.items.find(x=>x.id===itemId);
  if(!it) return;
  p.bag.equip[it.slot] = itemId;
  pushLog(state,"装备",`你装备了【${it.name}】。`,"good");
  recalcStats(state);
}
function unequipSlot(state, slot){
  const p=state.player;
  if(p.bag.equip[slot]){
    p.bag.equip[slot]=null;
    pushLog(state,"装备",`你卸下了${ITEM_SLOTS.find(s=>s.id===slot).name}。`,"info");
    recalcStats(state);
  }
}
function sellItem(state, itemId){
  const p=state.player;
  if(!inCity(state)){ pushLog(state,"商会","卖出需要在城镇。","warn"); return; }
  const idx = p.bag.items.findIndex(x=>x.id===itemId);
  if(idx<0) return;
  const it = p.bag.items[idx];
  // cannot sell equipped directly (auto unequip)
  for(const slot of ["weapon","armor","acc"]){
    if(p.bag.equip[slot]===itemId) p.bag.equip[slot]=null;
  }
  const price = Math.floor(it.price*0.45);
  p.stones += price;
  p.bag.items.splice(idx,1);
  pushLog(state,"商会",`你卖出【${it.name}】，获得${price}灵石。`,"good");
  recalcStats(state);
}

function setMainTech(state, techId){
  const p=state.player;
  ensurePlayerTechs(p);
  if(!p.techs.known[techId]){ pushLog(state,"功法","你尚未学会此功法。","warn"); return; }
  p.techs.mainId = techId;
  pushLog(state,"功法",`你将主修功法设为【${getTechById(techId).name}】。`,"info");
  recalcStats(state);
}

/* =========================
   Render
========================= */
const TABS = [
  { id:"cultivate", name:"修炼/闭关" },
  { id:"break", name:"突破" },
  { id:"explore", name:"地图探索" },
  { id:"sect", name:"宗门" },
  { id:"bag", name:"背包/装备" },
];

function renderTabs(){
  const wrap = $("tabs");
  wrap.innerHTML = "";
  for(const t of TABS){
    const b = document.createElement("button");
    b.className = "tabbtn" + (STATE.ui.tab===t.id ? " active" : "");
    b.textContent = t.name;
    b.onclick = ()=>{
      STATE.ui.tab = t.id;
      renderMain();
      renderTabs();
      saveAuto();
    };
    wrap.appendChild(b);
  }
}

function renderTop(){
  $("nowText").textContent = dateText(STATE);
  const cont = getContinent(STATE);
  $("locText").textContent = `${cont.name} · ${STATE.player.world.loc}`;
  $("lifeText").textContent = lifeText(STATE);
}

function renderChar(){
  const p = STATE.player;
  $("realmText").textContent = realmText(p);
  $("xpText").textContent = `${fmt(p.xp)} / ${fmt(p.xpNeed)}`;
  $("xpBar").style.width = `${clamp(p.xp/(p.xpNeed||1),0,1)*100}%`;

  const tm = techMods(p);
  $("techText").textContent = `${tm.name}（熟练${tm.mastery}/1000）`;
  $("techBar").style.width = `${clamp(tm.mastery/1000,0,1)*100}%`;

  $("hpText").textContent = `${fmt(p.hp)} / ${fmt(p.hpMax)}`;
  $("hpBar").style.width = `${clamp(p.hp/(p.hpMax||1),0,1)*100}%`;

  $("stoneText").textContent = fmt(p.stones);
  $("insText").textContent = fmt(p.insight);

  $("atkText").textContent = fmt(p.atk);
  $("defText").textContent = fmt(p.def);
  $("agiText").textContent = fmt(p.agi);
  $("mindText").textContent = fmt(p.mind);

  $("tagAlign").textContent = p._alignLabel;
  $("tagAlign").className = "tag " + (p._alignLabel==="正道"?"good":p._alignLabel==="魔道"?"bad":"");

  const statusBits = [];
  if(p.status.wound>0) statusBits.push(`伤势${p.status.wound}`);
  if(p.status.inner>0) statusBits.push(`内伤${p.status.inner}`);
  if(p.status.demonMark>0) statusBits.push(`心魔印记${p.status.demonMark}`);
  if(p.status.unstableDays>0) statusBits.push(`巩固${p.status.unstableDays}天`);
  $("statusText").textContent = statusBits.length? statusBits.join(" · "):"状态良好";
  $("statusDesc").textContent = p.sect.joined ? `宗门：${p.sect.name}（${TIER_LABEL[p.sect.tier]}·${ALIGN_LABEL[p.sect.align]}）｜名望${p.sect.fame||0}｜贡献${p.sect.contrib||0}` :
    `散修｜主大陆：${getContinent(STATE).name}｜主功法：${tm.name}`;
}

function renderMain(){
  const tab = STATE.ui.tab;
  const body = $("mainBody");
  const p = STATE.player;

  $("mainHint").textContent = STATE._gameOver ? "寿元已尽。你可以导出存档或重开。" :
    tab==="cultivate" ? "闭关变慢但更有策略：10年闭关主要代价是错过窗口（可用代理人缓解）。" :
    tab==="break" ? "准备度越高越稳，失败更像延期成本。" :
    tab==="explore" ? "探索获取资源、装备、功法与外部机缘。" :
    tab==="sect" ? "每大陆都有多家一/二/三流宗门。前往宗门驻地互动。" :
    "装备、功法、背包管理。";

  if(tab==="cultivate"){
    const envOpts = ENVIRONMENTS.map(e=>`<option value="${e.id}">${e.name}（效率×${e.eff}，风险×${e.risk}，费用${e.costStone}灵石）</option>`).join("");
    const supOpts = SUPPLIES.map(s=>`<option value="${s.id}">${s.name}（费用${s.cost}）</option>`).join("");
    const polOpts = DEMON_POLICY.map(d=>`<option value="${d.id}">${d.name}｜${d.desc}</option>`).join("");
    const agOpts  = AGENT_TASKS.map(a=>`<option value="${a.id}">${a.name}｜${a.desc}</option>`).join("");
    const techOpts = Object.keys(p.techs.known).map(id=>{
      const t=getTechById(id);
      const m=p.techs.known[id].mastery||0;
      return `<option value="${id}" ${id===p.techs.mainId?"selected":""}>${t.name}（熟练${m}）</option>`;
    }).join("");

    const wins = upcomingWindows(STATE, 360)
      .filter(w=>w.contId===p.world.contId)
      .slice(0,6)
      .map(w=>{
        const day = (w.startAbs - STATE.time.dayAbs);
        return `<div class="small">- ${w.typeName}：<b>${w.name}</b>（约${day}天后）</div>`;
      }).join("") || `<div class="small dim">暂无明显窗口（或你不在对应大陆）。</div>`;

    body.innerHTML = `
      <div class="split">
        <div class="card">
          <div class="small"><b>闭关方案</b></div>
          <div class="hr"></div>
          <div class="cols2">
            <div class="field">
              <label>时长</label>
              <select id="rtDays">
                <option value="30">30天（巩固/疗伤/练功法）</option>
                <option value="360">1年（主力档）</option>
                <option value="3600">10年（策略档：错过窗口）</option>
              </select>
            </div>
            <div class="field">
              <label>环境</label>
              <select id="rtEnv">${envOpts}</select>
            </div>
            <div class="field">
              <label>备品</label>
              <select id="rtSup">${supOpts}</select>
            </div>
            <div class="field">
              <label>心魔应对</label>
              <select id="rtDemon">${polOpts}</select>
            </div>
            <div class="field">
              <label>代理人</label>
              <select id="rtAgent">${agOpts}</select>
            </div>
            <div class="field">
              <label>主修功法</label>
              <select id="rtTech">${techOpts}</select>
            </div>
          </div>
          <div class="hr"></div>
          <div class="row" style="gap:10px; flex-wrap:wrap">
            <button class="btn primary" id="btnRetreat">开始闭关</button>
            <button class="btn" id="btnQuick7">野外探索7天</button>
            <button class="btn" id="btnQuick30">野外探索30天</button>
          </div>
        </div>

        <div class="card">
          <div class="small"><b>未来12个月窗口预告（本大陆）</b></div>
          <div class="hr"></div>
          ${wins}
          <div class="hr"></div>
          <div class="small dim">提示：10年闭关不会轻易炸炉，但错过窗口可能让机缘被人夺走；代理人可缓解。</div>
        </div>
      </div>
    `;

    $("btnRetreat").onclick = ()=>{
      if(STATE._gameOver) return;
      const days = parseInt($("rtDays").value,10);
      const envId = $("rtEnv").value;
      const supplyId = $("rtSup").value;
      const demonPolicyId = $("rtDemon").value;
      const agentId = $("rtAgent").value;
      const techId = $("rtTech").value;
      setMainTech(STATE, techId);
      retreat(STATE, { days, envId, supplyId, demonPolicyId, agentId });
      renderAll();
      saveAuto();
    };
    $("btnQuick7").onclick = ()=>{ exploreQuick(7); };
    $("btnQuick30").onclick = ()=>{ exploreQuick(30); };
  }

  if(tab==="break"){
    const prep = prepScore(STATE);
    const ch = successChanceFromPrep(prep);
    body.innerHTML = `
      <div class="card">
        <div class="small"><b>突破准备度</b></div>
        <div class="hr"></div>
        <div class="kv"><span>评估</span><b>${prep.label}</b></div>
        <div class="small dim">准备度来自：修为充盈、功法熟练、悟性储备、状态与环境。</div>
        <div class="hr"></div>
        <div class="kv"><span>成功率区间</span><b>${Math.round(ch.lo*100)}% ~ ${Math.round(ch.hi*100)}%</b></div>
        <div class="hr"></div>
        <div class="cols2">
          <div class="field">
            <label>投入悟性（提升稳健）</label>
            <input id="brIns" type="number" min="0" max="120" value="0"/>
            <div class="small dim">投入后会消耗悟性。</div>
          </div>
          <div class="field">
            <label>使用巩固散保底</label>
            <select id="brStab">
              <option value="0">不使用</option>
              <option value="1">使用（失败惩罚减半）</option>
            </select>
            <div class="small dim">需要你闭关时选择过巩固散或自行拥有（MVP暂按选择生效）。</div>
          </div>
        </div>
        <div class="hr"></div>
        <div class="row" style="gap:10px; flex-wrap:wrap">
          <button class="btn primary" id="btnBreak">冲关</button>
          <button class="btn" id="btnStabilize">巩固修为（30天）</button>
        </div>
      </div>
    `;
    $("btnBreak").onclick = ()=>{
      const spend = parseInt($("brIns").value||"0",10);
      const useStab = $("brStab").value==="1";
      doBreakthrough(STATE, spend, useStab);
      renderAll();
      saveAuto();
    };
    $("btnStabilize").onclick = ()=>{
      advanceDays(STATE, 30, { silent:true });
      STATE.player.status.unstableDays = Math.max(0, STATE.player.status.unstableDays-40);
      pushLog(STATE,"巩固","你花费30天巩固修为，气息更稳。","good");
      normalizeStatus(STATE); recalcStats(STATE);
      renderAll(); saveAuto();
    };
  }

  if(tab==="explore"){
    const cont = getContinent(STATE);
    const map = getMap(STATE);
    const n = map.size;
    const tiles = map.tiles.map(t=>{
      const discovered = t.discovered;
      const isYou = (t.x===STATE.player.world.x && t.y===STATE.player.world.y);
      const cls = ["tile", discovered?"":"unknown", isYou?"you":"", (t.type!=="wild" && discovered)?"poi":""].filter(Boolean).join(" ");
      const sym = !discovered ? "?" : t.type==="city" ? "城" : t.type==="sect" ? "宗" : t.type==="ruin" ? "遗" : t.type==="port" ? "港" : (t.poi?.biome==="雪原"?"雪":t.poi?.biome==="密林"?"林":t.poi?.biome==="山地"?"山":"·");
      return `<div class="${cls}" data-x="${t.x}" data-y="${t.y}" title="${discovered? tileTitle(t):"未探索"}">${sym}</div>`;
    }).join("");

    const sel = STATE.ui.selectedTile;
    let selHtml = `<div class="small dim">点击格子查看信息。</div>`;
    if(sel){
      const t = getTile(STATE, sel.x, sel.y);
      if(t){
        selHtml = `
          <div class="small"><b>${t.discovered? tileTitle(t):"未知区域"}</b></div>
          <div class="small dim">坐标：(${sel.x},${sel.y})｜地形：${t.poi?.biome||"—"}</div>
          <div class="hr"></div>
          <div class="row" style="gap:10px; flex-wrap:wrap">
            <button class="btn" id="btnGoSel">前往</button>
            <button class="btn" id="btnExploreHere">在此行动</button>
          </div>
        `;
      }
    }

    const travelOpts = CONTINENTS.filter(c=>c.id!==cont.id)
      .map(c=>`<option value="${c.id}">${c.name}</option>`).join("");

    body.innerHTML = `
      <div class="split">
        <div class="card">
          <div class="small"><b>五洲地图：${cont.name}</b></div>
          <div class="small dim">${cont.desc}</div>
          <div class="hr"></div>
          <div class="mapWrap">
            <div class="grid" style="--n:${n}">${tiles}</div>
            <div style="min-width:240px; flex:1">
              <div class="card">
                <div class="small"><b>格子信息</b></div>
                <div class="hr"></div>
                ${selHtml}
                <div class="hr"></div>
                <div class="legend">
                  <span class="badge">城=城镇</span>
                  <span class="badge">宗=宗门</span>
                  <span class="badge">遗=遗迹</span>
                  <span class="badge">港=渡界港</span>
                  <span class="badge">?=未探索</span>
                </div>
              </div>
              <div class="card" style="margin-top:12px">
                <div class="small"><b>快捷行动</b></div>
                <div class="hr"></div>
                <div class="row" style="gap:10px; flex-wrap:wrap">
                  <button class="btn" id="mvU">↑</button>
                  <button class="btn" id="mvL">←</button>
                  <button class="btn" id="mvD">↓</button>
                  <button class="btn" id="mvR">→</button>
                  <button class="btn primary" id="btnExploreHere2">在此行动</button>
                </div>
                <div class="hr"></div>
                <div class="row" style="gap:10px; flex-wrap:wrap">
                  <button class="btn" id="btnBuyItem">城镇买装备</button>
                  <button class="btn" id="btnBuyTech">城镇买功法</button>
                </div>
              </div>
              <div class="card" style="margin-top:12px">
                <div class="small"><b>渡界（需在港口）</b></div>
                <div class="hr"></div>
                <div class="row" style="gap:10px; flex-wrap:wrap">
                  <select id="selCont">${travelOpts}</select>
                  <button class="btn" id="btnTravel">前往</button>
                </div>
                <div class="small dim" style="margin-top:8px">提示：渡界耗时30天并支付费用，适合跨大陆发展。</div>
              </div>
            </div>
          </div>
        </div>
      </div>
    `;

    // tile click
    document.querySelectorAll(".tile").forEach(el=>{
      el.onclick = ()=>{
        STATE.ui.selectedTile = { x: parseInt(el.dataset.x,10), y: parseInt(el.dataset.y,10) };
        renderMain(); saveAuto();
      };
    });

    $("mvU").onclick=()=>{ move(STATE,0,-1); renderAll(); saveAuto(); };
    $("mvD").onclick=()=>{ move(STATE,0,1); renderAll(); saveAuto(); };
    $("mvL").onclick=()=>{ move(STATE,-1,0); renderAll(); saveAuto(); };
    $("mvR").onclick=()=>{ move(STATE,1,0); renderAll(); saveAuto(); };

    const exploreBtn = $("btnExploreHere");
    if(exploreBtn){
      exploreBtn.onclick=()=>{ exploreHere(STATE); renderAll(); saveAuto(); };
    }
    $("btnExploreHere2").onclick=()=>{ exploreHere(STATE); renderAll(); saveAuto(); };
    $("btnBuyItem").onclick=()=>{ buyRandomItem(STATE); renderAll(); saveAuto(); };
    $("btnBuyTech").onclick=()=>{ buyTechniqueScroll(STATE); renderAll(); saveAuto(); };
    $("btnTravel").onclick=()=>{
      const target = $("selCont").value;
      travelToContinent(STATE, target);
      renderAll(); saveAuto();
    };

    const goSel = $("btnGoSel");
    if(goSel){
      goSel.onclick=()=>{
        const t = STATE.ui.selectedTile;
        if(!t) return;
        // path cost: manhattan*2 days
        const dx = Math.abs(t.x-STATE.player.world.x);
        const dy = Math.abs(t.y-STATE.player.world.y);
        const steps = dx+dy;
        if(steps===0) return;
        // move step by step to allow encounters; simplified: teleport along straight lines
        for(let i=0;i<dx;i++) move(STATE, t.x>STATE.player.world.x?1:-1, 0);
        for(let i=0;i<dy;i++) move(STATE, 0, t.y>STATE.player.world.y?1:-1);
        renderAll(); saveAuto();
      };
    }
  }

  if(tab==="sect"){
    const contId = p.world.contId;
    const list = (STATE.world.sects||[])
      .filter(s=>s.contId===contId)
      .sort((a,b)=> (a.tier===b.tier? a.name.localeCompare(b.name): (a.tier<b.tier?-1:1)))
      .map(s=>{
        const pos = s.pos ? `(${s.pos.x},${s.pos.y})` : "(?)";
        const joinReq = `${REALMS[s.realmReq].name}+｜名望${s.fameReq}+｜入门费${s.joinFee}`;
        return `
          <div class="itemRow">
            <div>
              <b>${s.name}</b>
              <div class="itemMeta">
                <span class="pill2">${TIER_LABEL[s.tier]}</span>
                <span class="pill2">${ALIGN_LABEL[s.align]}</span>
                <span class="pill2">${getContinent({player:{world:{contId:s.contId}}}).name}</span>
                <span class="pill2">坐标${pos}</span>
              </div>
              <div class="small dim">${joinReq}｜洞府解锁：${ENVIRONMENTS.find(e=>e.id===s.envUnlock)?.name||"—"}</div>
            </div>
            <div class="row" style="gap:8px; align-items:center">
              <button class="btn" data-goto="${s.id}">定位</button>
            </div>
          </div>
        `;
      }).join("") || `<div class="small dim">本大陆暂无宗门？（通常不会）</div>`;

    const atSect = currentSectTile(STATE);
    body.innerHTML = `
      <div class="split">
        <div class="card">
          <div class="small"><b>本大陆宗门列表：${getContinent(STATE).name}</b></div>
          <div class="hr"></div>
          <div class="list">${list}</div>
        </div>

        <div class="card">
          <div class="small"><b>当前互动</b></div>
          <div class="hr"></div>
          <div class="small">${atSect? `你在 <b>${atSect.name}</b> 驻地。`:"你当前不在宗门驻地。前往宗门格子后可互动。"}</div>
          <div class="hr"></div>
          <div class="row" style="gap:10px; flex-wrap:wrap">
            <button class="btn primary" id="btnJoin">尝试加入</button>
            <button class="btn" id="btnChore">做宗门差事（30天）</button>
            <button class="btn" id="btnLeave">退出宗门</button>
          </div>
          <div class="hr"></div>
          <div class="small dim">提示：后续可扩展宗门等级、正邪冲突、追杀/庇护、宗门战争与职位体系。</div>
        </div>
      </div>
    `;

    // locate
    body.querySelectorAll("[data-goto]").forEach(btn=>{
      btn.onclick = ()=>{
        const id = btn.getAttribute("data-goto");
        const s = STATE.world.sects.find(x=>x.id===id);
        if(!s || !s.pos){ return; }
        STATE.ui.tab="explore";
        STATE.ui.selectedTile = { x:s.pos.x, y:s.pos.y };
        renderTabs(); renderMain(); saveAuto();
      };
    });

    $("btnJoin").onclick=()=>{ tryJoinCurrentSect(STATE); renderAll(); saveAuto(); };
    $("btnChore").onclick=()=>{ sectChore(STATE); renderAll(); saveAuto(); };
    $("btnLeave").onclick=()=>{ leaveSect(STATE); renderAll(); saveAuto(); };
  }

  if(tab==="bag"){
    const p=STATE.player;
    const eq = p.bag.equip;
    const byId = new Map(p.bag.items.map(it=>[it.id,it]));
    const eqRow = (slot)=>{
      const it = eq[slot] ? byId.get(eq[slot]) : null;
      const slotName = ITEM_SLOTS.find(s=>s.id===slot).name;
      return `
        <div class="itemRow">
          <div>
            <b>${slotName}</b>
            <div class="small dim">${it? `【${it.name}】 ${rarText(it)}｜${statText(it)} ${it.desc?("｜"+it.desc):""}`:"（未装备）"}</div>
          </div>
          <div class="row" style="gap:8px">
            ${it? `<button class="btn" data-uneq="${slot}">卸下</button>`:""}
          </div>
        </div>
      `;
    };

    const inv = p.bag.items.map(it=>{
      return `
        <div class="itemRow">
          <div>
            <b>${it.name}</b>
            <div class="itemMeta">
              <span class="pill2">${ITEM_SLOTS.find(s=>s.id===it.slot).name}</span>
              <span class="pill2">${rarText(it)}</span>
              <span class="pill2">标价${it.price}</span>
            </div>
            <div class="small dim">${statText(it)} ${it.desc?("｜"+it.desc):""}</div>
          </div>
          <div class="row" style="gap:8px; align-items:center">
            <button class="btn" data-eq="${it.id}">装备</button>
            <button class="btn" data-sell="${it.id}">卖出</button>
          </div>
        </div>
      `;
    }).join("") || `<div class="small dim">背包空空如也。去探索、遗迹或城镇交易吧。</div>`;

    const techList = Object.keys(p.techs.known).map(id=>{
      const t=getTechById(id);
      const m=p.techs.known[id].mastery||0;
      const active = id===p.techs.mainId;
      return `
        <div class="itemRow">
          <div>
            <b>${t.name}${active?"（主修）":""}</b>
            <div class="small dim">${t.style}｜熟练${m}/1000｜${t.desc}</div>
          </div>
          <div class="row" style="gap:8px">
            ${active? "" : `<button class="btn" data-main="${id}">设为主修</button>`}
          </div>
        </div>
      `;
    }).join("");

    body.innerHTML = `
      <div class="split">
        <div class="card">
          <div class="small"><b>装备栏</b></div>
          <div class="hr"></div>
          <div class="list">
            ${eqRow("weapon")}
            ${eqRow("armor")}
            ${eqRow("acc")}
          </div>
          <div class="hr"></div>
          <div class="small dim">卖出需要在城镇。装备与功法会影响属性与闭关效率/风险。</div>
        </div>

        <div class="card">
          <div class="small"><b>背包</b></div>
          <div class="hr"></div>
          <div class="list">${inv}</div>
        </div>
      </div>

      <div class="card" style="margin-top:12px">
        <div class="small"><b>功法库</b></div>
        <div class="hr"></div>
        <div class="list">${techList}</div>
      </div>
    `;

    body.querySelectorAll("[data-eq]").forEach(btn=>{
      btn.onclick=()=>{ equipItem(STATE, btn.getAttribute("data-eq")); renderAll(); saveAuto(); };
    });
    body.querySelectorAll("[data-uneq]").forEach(btn=>{
      btn.onclick=()=>{ unequipSlot(STATE, btn.getAttribute("data-uneq")); renderAll(); saveAuto(); };
    });
    body.querySelectorAll("[data-sell]").forEach(btn=>{
      btn.onclick=()=>{ sellItem(STATE, btn.getAttribute("data-sell")); renderAll(); saveAuto(); };
    });
    body.querySelectorAll("[data-main]").forEach(btn=>{
      btn.onclick=()=>{ setMainTech(STATE, btn.getAttribute("data-main")); renderAll(); saveAuto(); };
    });
  }
}

function rarText(it){
  const r = ITEM_RARITY.find(x=>x.id===it.rarity);
  return r? r.name : it.rarity;
}
function statText(it){
  const s=it.stats||{};
  const bits=[];
  if(s.atk) bits.push(`攻+${s.atk}`);
  if(s.def) bits.push(`防+${s.def}`);
  if(s.agi) bits.push(`敏+${s.agi}`);
  if(s.mind) bits.push(`神+${s.mind}`);
  if(it.extra && it.extra.cultEff) bits.push(`修+${Math.round(it.extra.cultEff*100)}%`);
  if(it.extra && it.extra.riskMul) bits.push(`险×${it.extra.riskMul.toFixed(2)}`);
  return bits.join(" · ") || "—";
}

function exploreQuick(days){
  if(STATE._gameOver) return;
  // quick action: doesn't move, just explore current tile type
  const t = getTile(STATE, STATE.player.world.x, STATE.player.world.y);
  if(t && t.type!=="wild"){
    pushLog(STATE,"探索","快捷探索建议在野外进行。你可以在此行动按钮处理当前地点。","info");
    renderAll(); return;
  }
  // simulate repeated exploreHere in chunks
  const n = Math.max(1, Math.floor(days/7));
  for(let i=0;i<n;i++){
    const p=STATE.player;
    const cont=getContinent(STATE);
    advanceDays(STATE, 7, { silent:true });
    const gainStone = Math.floor((randi(18,55) + stagePower(p.realmIdx,p.stageIdx)*8) * cont.mods.res);
    const gainIns = Math.floor((randi(0,2) + (rand()<0.2?1:0)) * p._insEffMul);
    p.stones += gainStone; p.insight += gainIns;
    if(rand()<0.18*cont.mods.res){
      const it=genItem(STATE,"gather");
      p.bag.items.push(it);
      pushLog(STATE,"探索",`野外探索7天：+${gainStone}灵石，+${gainIns}悟性，获得【${it.name}】。`,"good");
    }else{
      pushLog(STATE,"探索",`野外探索7天：+${gainStone}灵石，+${gainIns}悟性。`,"good");
    }
    if(rand()<0.16*cont.mods.risk){
      const diff=encounterDifficulty(STATE);
      pushLog(STATE,"遭遇",`探索途中遭遇敌人（难度${diff}）。`,"warn");
      resolveFight(STATE, diff);
    }
  }
  normalizeStatus(STATE); recalcStats(STATE);
  renderAll(); saveAuto();
}

function tileTitle(t){
  if(t.type==="city") return `城镇：${t.poi.name}`;
  if(t.type==="sect") return `宗门：${t.poi.name}`;
  if(t.type==="ruin") return `遗迹：${t.poi.name}`;
  if(t.type==="port") return `港口：${t.poi.name}`;
  return `野外：${t.poi?.biome||"荒野"}`;
}

function renderLog(){
  const per = 10;
  const page = STATE.ui.logPage||0;
  const start = page*per;
  const items = STATE.log.slice(start, start+per);
  const wrap = $("panelLog");
  const lines = items.map(it=>{
    const cls = it.type==="good"?"log good":it.type==="bad"?"log bad":it.type==="warn"?"log warn":"log";
    const msg = it.type==="info_html" ? it.msg : escapeHtml(it.msg);
    return `<div class="${cls}"><div class="small dim">${escapeHtml(it.t)} · ${escapeHtml(it.who)}</div><div>${msg}</div></div>`;
  }).join("") || `<div class="small dim">暂无日志</div>`;
  const totalPages = Math.max(1, Math.ceil(STATE.log.length/per));
  wrap.innerHTML = `
    <div class="hd">
      <div>
        <h2>事件日志</h2>
        <div class="hint">最新在上｜每页${per}条</div>
      </div>
      <div class="row" style="gap:8px">
        <button class="btn" id="logPrev">上一页</button>
        <div class="pill"><span>页</span><b class="mono">${page+1}/${totalPages}</b></div>
        <button class="btn" id="logNext">下一页</button>
      </div>
    </div>
    <div class="bd">${lines}</div>
  `;
  $("logPrev").onclick=()=>{ STATE.ui.logPage = Math.max(0, page-1); renderLog(); saveAuto(); };
  $("logNext").onclick=()=>{ STATE.ui.logPage = Math.min(totalPages-1, page+1); renderLog(); saveAuto(); };
}

function escapeHtml(s){
  return (""+s).replace(/[&<>"']/g, m=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[m]));
}

function renderAll(){
  renderTop();
  renderChar();
  renderTabs();
  renderMain();
  renderLog();
}

/* =========================
   Save / Load
========================= */
function saveAuto(){
  try{
    localStorage.setItem(SAVE_KEY, JSON.stringify(STATE));
  }catch(e){}
}
function loadAuto(){
  try{
    const raw = localStorage.getItem(SAVE_KEY);
    if(!raw) return null;
    const obj = JSON.parse(raw);
    return migrateSave(obj);
  }catch(e){
    return null;
  }
}

function exportSave(){
  const data = JSON.stringify(STATE);
  navigator.clipboard.writeText(data).then(()=>{
    pushLog(STATE,"系统","存档已复制到剪贴板。","good");
    renderLog();
  }).catch(()=>{
    prompt("复制以下存档文本：", data);
  });
}
function importSave(){
  const txt = prompt("粘贴存档文本：");
  if(!txt) return;
  try{
    const obj = JSON.parse(txt);
    const m = migrateSave(obj);
    if(!m) throw new Error("bad save");
    STATE = m;
    bootstrapWorld(STATE);
    pushLog(STATE,"系统","存档导入成功。","good");
    renderAll();
    saveAuto();
  }catch(e){
    alert("导入失败：存档格式不正确。");
  }
}
function resetSave(){
  if(!confirm("确定重开？将清除本地存档。")) return;
  localStorage.removeItem(SAVE_KEY);
  STATE = newGame();
  bootstrapWorld(STATE);
  renderAll();
  saveAuto();
}

/* =========================
   Init
========================= */
function bootstrapWorld(state){
  // ensure windows current year
  ensureWindowsForYear(state, getYear(state));
  // generate sects/maps if missing
  if(!state.world.sects || !state.world.sects.length){
    genSectsForAllContinents(state);
  }
  // ensure maps exist and place sects
  placeSectsOnMaps(state);

  // set initial tile discovered
  const tile = getTile(state, state.player.world.x, state.player.world.y);
  if(tile) tile.discovered=true;

  recalcStats(state);
}

function newGame(){
  const s = defaultPlayer();
  pushLog(s, "系统", "欢迎来到修真RPG v0.2：五洲地图、装备与功法、宗门多势力（MVP）。建议先在【地图探索】熟悉城镇/宗门/遗迹。", "info");
  ensureWindowsForYear(s, 1);
  return s;
}

function bindTopButtons(){
  $("btnSave").onclick=()=>{ saveAuto(); pushLog(STATE,"系统","已保存。","good"); renderLog(); };
  $("btnExport").onclick=()=>{ exportSave(); };
  $("btnImport").onclick=()=>{ importSave(); };
  $("btnReset").onclick=()=>{ resetSave(); };
}

function main(){
  STATE = loadAuto() || newGame();
  bootstrapWorld(STATE);
  bindTopButtons();
  renderAll();
}

main();

})();

</script>
</body>
</html>
